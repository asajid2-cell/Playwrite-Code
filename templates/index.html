<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Harmonizer Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='modern.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='visualizer.css') }}">
</head>
<body class="page {% if track_id %}state-player{% else %}state-home{% endif %}" data-mode="{{ mode }}">
    <div class="music-field" aria-hidden="true">
        <div class="music track one"><span></span><span></span><span></span><span></span><span></span></div>
        <div class="music track two"><span></span><span></span><span></span><span></span><span></span></div>
        <div class="music track three"><span></span><span></span><span></span><span></span><span></span></div>
    </div>

    <div class="page-shell">
        <header class="hero">
            <div class="hero-meta">
                <div class="badge">Harmonizer Lab</div>
                <h1>Autocanonizer</h1>
                <p>Analyze a track and perform it as a canon—clean visuals, smooth overlays, zero fuss.</p>
            </div>
        </header>

        <main class="layout">
            <section class="panel intake-panel" id="intake-panel">
                <h2>Load A Track</h2>
                <form id="process-form" enctype="multipart/form-data" novalidate>
                    <div class="section-title">Engine</div>
                    <div class="toggle-group" id="algorithm-toggle">
                        <button type="button" data-algorithm="canon" class="toggle active">Autocanonizer</button>
                        <button type="button" data-algorithm="jukebox" class="toggle">Eternal Jukebox</button>
                        <button type="button" data-algorithm="eternal" class="toggle">Eternal Canonizer</button>
                    </div>
                    <input type="hidden" name="algorithm" value="canon" id="algorithm-input">

                    <div class="section-title">Source</div>
                    <div class="toggle-group" id="source-toggle">
                        <button type="button" data-source="upload" class="toggle active">Upload Audio</button>
                        <button type="button" data-source="youtube" class="toggle">YouTube</button>
                    </div>
                    <input type="hidden" name="source" value="upload" id="source-input">

                    <div class="source-pane" id="upload-pane">
                        <label class="field">
                            <span>Audio file</span>
                            <input type="file" name="audio" accept="audio/*">
                        </label>
                    </div>

                    <div class="source-pane hidden" id="youtube-pane">
                        <label class="field">
                            <span>YouTube link</span>
                            <input type="url" name="youtube_url" placeholder="https://www.youtube.com/watch?v=...">
                        </label>
                    </div>

                    <div class="metadata-grid">
                        <label class="field">
                            <span>Title <small>(optional)</small></span>
                            <input type="text" name="title" placeholder="Auto-detected when possible">
                        </label>
                        <label class="field">
                            <span>Artist <small>(optional)</small></span>
                            <input type="text" name="artist" placeholder="Auto-detected when possible">
                        </label>
                    </div>

                    <button type="submit" class="cta">Transform Track</button>
                </form>
                <div id="form-status" class="status-panel" role="status" aria-live="polite"></div>
                <div class="tips">
                    <p>YouTube imports require <code>ffmpeg</code> in PATH.</p>
                    <p class="meta">CLI: <code>python analysis/analyze_track.py --help</code></p>
                </div>
            </section>

            <section class="panel viz-panel music-frame" id="viz-panel">
                <header class="viz-header">
                    <div class="viz-headline">
                        <h2>Visualizer</h2>
                        <p id="info"></p>
                    </div>
                    <div class="viz-actions">
                        <button id="play" class="viz-button">Play</button>
                        <span class="viz-timer" id="mtime">00:00:00</span>
                        <span class="viz-mode-pill" id="mode-pill">
                            {% if mode == 'jukebox' %}
                                Eternal Jukebox
                            {% elif mode == 'eternal' %}
                                Eternal Canonizer
                            {% else %}
                                Autocanonizer
                            {% endif %}
                        </span>
                    </div>
                </header>
                <div id="canon-controls" class="viz-tuning hidden">
                    <label class="canon-advanced-toggle">
                        <input type="checkbox" id="canon-advanced-toggle">
                        <span>Advanced Mode</span>
                    </label>
                    <button type="button" id="canon-settings-toggle" class="viz-button ghost">Canon Controls</button>
                    <button type="button" id="canon-regenerate" class="viz-button ghost">Regenerate</button>
                    <button type="button" id="canon-reset" class="viz-button ghost">Reset</button>
                </div>
                <div id="canon-settings-panel" class="canon-settings-panel hidden" aria-hidden="true">
                    <div class="canon-setting-row">
                        <label for="canon-min-offset">Min Offset</label>
                        <input type="range" id="canon-min-offset" min="1" max="32" step="1" value="8">
                        <span class="canon-setting-value" data-setting-display="minOffsetBeats">8 beats</span>
                    </div>
                    <p class="canon-setting-hint">Shortest distance (in beats) between the main voice and the canon voice.</p>
                    <div class="canon-setting-row">
                        <label for="canon-max-offset">Max Offset</label>
                        <input type="range" id="canon-max-offset" min="8" max="96" step="1" value="64">
                        <span class="canon-setting-value" data-setting-display="maxOffsetBeats">64 beats</span>
                    </div>
                    <p class="canon-setting-hint">Farthest beat separation to consider when searching for canon partners.</p>
                    <div class="canon-setting-row">
                        <label for="canon-dwell">Hold Duration</label>
                        <input type="range" id="canon-dwell" min="1" max="16" step="1" value="6">
                        <span class="canon-setting-value" data-setting-display="dwellBeats">6 beats</span>
                    </div>
                    <p class="canon-setting-hint">How long the canon sticks with each offset before exploring a new one.</p>
                    <div class="canon-setting-row">
                        <label for="canon-density">Texture</label>
                        <input type="range" id="canon-density" min="1" max="5" step="1" value="2">
                        <span class="canon-setting-value" data-setting-display="density">Light (2/5)</span>
                    </div>
                    <p class="canon-setting-hint">Controls how many overlay arcs are introduced across the song.</p>
                    <div class="canon-setting-row">
                        <label for="canon-variation">Variation</label>
                        <input type="range" id="canon-variation" min="0" max="6" step="1" value="2">
                        <span class="canon-setting-value" data-setting-display="variation">2</span>
                    </div>
                    <p class="canon-setting-hint">Adds a touch of randomness to keep canon jumps from feeling predictable.</p>
                    <p class="canon-settings-note">Adjust the canon voice in real-time. Tap Regenerate to explore alternate overlays without reloading your track.</p>
                </div>
                <div class="viz-status" id="status-panel"></div>
                <div id="error"></div>
                <div id="tiles" class="tiles-canvas"></div>
                <footer class="viz-footer">
                    Press space to toggle playback &middot; Drag the window wider for more detail
                </footer>
            </section>
        </main>

        <footer class="footer">
            © Harmonizer Lab
        </footer>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.3/jquery-ui.min.js"></script>
    <script src="{{ url_for('static', filename='js/underscore-min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/raphael-min.js') }}"></script>
    <script src="{{ url_for('static', filename='jremix.js') }}"></script>
    <script src="{{ url_for('static', filename='js/visualizer.js') }}"></script>
    <script>
    (function() {
        const body = document.body;
        const algorithmToggle = document.getElementById('algorithm-toggle');
        const sourceToggle = document.getElementById('source-toggle');
        const algorithmInput = document.getElementById('algorithm-input');
        const sourceInput = document.getElementById('source-input');
        const uploadPane = document.getElementById('upload-pane');
        const youtubePane = document.getElementById('youtube-pane');
        const form = document.getElementById('process-form');
        const statusPanel = document.getElementById('form-status');
        const modeFromBody = body.dataset.mode || "canon";

        const setState = (state) => {
            body.classList.remove('state-home', 'state-player');
            body.classList.add(state);
        };

        if ({{ 'true' if track_id else 'false' }}) {
            setState('state-player');
        } else {
            setState('state-home');
        }

        function syncAlgorithmButtons(targetMode) {
            algorithmToggle.querySelectorAll('.toggle').forEach(btn => btn.classList.remove('active'));
            const match = algorithmToggle.querySelector('[data-algorithm=\"' + targetMode + '\"]');
            if (match) {
                match.classList.add('active');
                algorithmInput.value = targetMode;
            }
        }

        if (modeFromBody === "jukebox" || modeFromBody === "eternal" || modeFromBody === "canon") {
            syncAlgorithmButtons(modeFromBody);
        }

        algorithmToggle.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-algorithm]');
            if (!button) {
                return;
            }
            syncAlgorithmButtons(button.dataset.algorithm);
        });

        sourceToggle.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-source]');
            if (!button) {
                return;
            }
            sourceToggle.querySelectorAll('.toggle').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const source = button.dataset.source;
            sourceInput.value = source;
            if (source === 'upload') {
                uploadPane.classList.remove('hidden');
                youtubePane.classList.add('hidden');
            } else {
                youtubePane.classList.remove('hidden');
                uploadPane.classList.add('hidden');
            }
        });

        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            statusPanel.textContent = '';
            const source = sourceInput.value;
            if (source === 'upload') {
                const fileInput = form.querySelector('input[name="audio"]');
                if (!fileInput.files || fileInput.files.length === 0) {
                    statusPanel.textContent = 'Please choose an audio file to upload.';
                    return;
                }
            } else {
                const urlField = form.querySelector('input[name="youtube_url"]');
                if (!urlField.value) {
                    statusPanel.textContent = 'Please paste a YouTube link.';
                    return;
                }
            }

            const submitButton = form.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            submitButton.textContent = 'Processing...';
            statusPanel.textContent = 'Analyzing audio... this can take a minute.';

            try {
                const formData = new FormData(form);
                const response = await fetch('/api/process', {
                    method: 'POST',
                    body: formData
                });
                const payload = await response.json();
                if (!response.ok) {
                    throw new Error(payload.error || 'Something went wrong.');
                }
                statusPanel.textContent = 'Ready! Loading the visualizer...';
                window.location.href = payload.redirect;
            } catch (err) {
                statusPanel.textContent = err.message;
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Transform Track';
            }
        });
        const canonControls = document.getElementById('canon-controls');
        const canonPanel = document.getElementById('canon-settings-panel');
        const canonToggleBtn = document.getElementById('canon-settings-toggle');
        const canonRegenerateBtn = document.getElementById('canon-regenerate');
        const canonResetBtn = document.getElementById('canon-reset');
        const densityLabels = ['Sparse', 'Light', 'Balanced', 'Rich', 'Dense'];
        const defaultCanonSettings = {
            minOffsetBeats: 8,
            maxOffsetBeats: 64,
            dwellBeats: 6,
            density: 2,
            variation: 2
        };

        function connectSlider(id, key, formatter, defaultValue) {
            const input = document.getElementById(id);
            const display = document.querySelector(`[data-setting-display="${key}"]`);
            if (!input) {
                return;
            }
            const formatValue = formatter || ((val) => val);
            const updateDisplay = (val) => {
                if (display) {
                    display.textContent = formatValue(val);
                }
            };
            const parse = (val) => parseInt(val, 10) || 0;
            updateDisplay(parse(input.value));
            input.addEventListener('input', () => {
                const numeric = parse(input.value);
                updateDisplay(numeric);
                if (typeof window.updateCanonSetting === 'function') {
                    window.updateCanonSetting(key, numeric);
                }
            });
            if (defaultValue !== undefined) {
                const min = input.min ? parseInt(input.min, 10) : defaultValue;
                const max = input.max ? parseInt(input.max, 10) : defaultValue;
                const initial = Math.min(max, Math.max(min, defaultValue));
                input.value = initial;
                input.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }

        connectSlider('canon-min-offset', 'minOffsetBeats', (v) => `${v} beats`, defaultCanonSettings.minOffsetBeats);
        connectSlider('canon-max-offset', 'maxOffsetBeats', (v) => `${v} beats`, defaultCanonSettings.maxOffsetBeats);
        connectSlider('canon-dwell', 'dwellBeats', (v) => `${v} beats`, defaultCanonSettings.dwellBeats);
        connectSlider('canon-density', 'density', (v) => {
            const index = Math.min(densityLabels.length - 1, Math.max(0, v - 1));
            return `${densityLabels[index]} (${v}/5)`;
        }, defaultCanonSettings.density);
        connectSlider('canon-variation', 'variation', (v) => v.toString(), defaultCanonSettings.variation);

        const minOffsetSlider = document.getElementById('canon-min-offset');
        const maxOffsetSlider = document.getElementById('canon-max-offset');
        if (minOffsetSlider && maxOffsetSlider) {
            const syncMaxMin = () => {
                const minVal = parseInt(minOffsetSlider.value, 10) || 1;
                const maxVal = parseInt(maxOffsetSlider.value, 10) || (minVal + 1);
                const newMin = Math.max(2, minVal + 1);
                maxOffsetSlider.min = newMin;
                if (maxVal <= minVal) {
                    maxOffsetSlider.value = newMin;
                    maxOffsetSlider.dispatchEvent(new Event('input', { bubbles: true }));
                }
            };
            minOffsetSlider.addEventListener('input', syncMaxMin);
            syncMaxMin();
        }

        const canonAdvancedToggle = document.getElementById('canon-advanced-toggle');
        const sliderElements = canonPanel ? Array.from(canonPanel.querySelectorAll('input[type="range"]')) : [];
        const controlButtons = [canonRegenerateBtn, canonResetBtn];

        const setCanonControlsEnabled = (enabled) => {
            const allow = !!enabled;
            sliderElements.forEach((el) => {
                el.disabled = !allow;
            });
            controlButtons.forEach((btn) => {
                if (btn) {
                    btn.disabled = !allow;
                }
            });
            if (canonToggleBtn) {
                canonToggleBtn.disabled = !allow;
            }
            if (!allow && canonPanel) {
                canonPanel.classList.add('hidden');
                canonPanel.setAttribute('aria-hidden', 'true');
            }
        };

        setCanonControlsEnabled(false);

        if (canonAdvancedToggle) {
            canonAdvancedToggle.checked = typeof window.isCanonAdvancedEnabled === 'function' ? window.isCanonAdvancedEnabled() : false;
            canonAdvancedToggle.addEventListener('change', () => {
                const enabled = canonAdvancedToggle.checked;
                if (typeof window.setCanonAdvancedEnabled === 'function') {
                    window.setCanonAdvancedEnabled(enabled);
                }
            });
        }

        if (canonToggleBtn && canonPanel) {
            canonToggleBtn.addEventListener('click', () => {
                const isHidden = canonPanel.classList.toggle('hidden');
                canonPanel.setAttribute('aria-hidden', isHidden ? 'true' : 'false');
            });
        }

        if (canonRegenerateBtn) {
            canonRegenerateBtn.addEventListener('click', () => {
                if (typeof window.regenerateCanonMappingManually === 'function') {
                    window.regenerateCanonMappingManually();
                }
            });
        }

        if (canonResetBtn) {
            canonResetBtn.addEventListener('click', () => {
                const sliderMap = [
                    ['canon-min-offset', defaultCanonSettings.minOffsetBeats],
                    ['canon-max-offset', defaultCanonSettings.maxOffsetBeats],
                    ['canon-dwell', defaultCanonSettings.dwellBeats],
                    ['canon-density', defaultCanonSettings.density],
                    ['canon-variation', defaultCanonSettings.variation]
                ];
                sliderMap.forEach(([id, value]) => {
                    const slider = document.getElementById(id);
                    if (!slider) {
                        return;
                    }
                    const min = slider.min ? parseInt(slider.min, 10) : value;
                    const max = slider.max ? parseInt(slider.max, 10) : value;
                    const target = Math.min(max, Math.max(min, value));
                    slider.value = target;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                });
            });
        }

        window.setCanonUiVisibility = (visible) => {
            if (!canonControls) {
                return;
            }
            canonControls.classList.toggle('hidden', !visible);
            if (!visible && canonPanel) {
                canonPanel.classList.add('hidden');
                canonPanel.setAttribute('aria-hidden', 'true');
            }
            if (!visible) {
                setCanonControlsEnabled(false);
            } else {
                const current = typeof window.isCanonAdvancedEnabled === 'function' ? window.isCanonAdvancedEnabled() : false;
                setCanonControlsEnabled(current);
                if (canonAdvancedToggle) {
                    canonAdvancedToggle.checked = current;
                }
            }
        };

        window.onCanonTrackReady = (payload) => {
            if (!canonControls) {
                return;
            }
            if (!payload || !payload.beats) {
                canonControls.classList.add('hidden');
                if (canonPanel) {
                    canonPanel.classList.add('hidden');
                    canonPanel.setAttribute('aria-hidden', 'true');
                }
                setCanonControlsEnabled(false);
                return;
            }
            canonControls.classList.remove('hidden');
            const beats = payload.beats;
            if (payload.minOffsetBeats) {
                defaultCanonSettings.minOffsetBeats = payload.minOffsetBeats;
            }
            if (payload.maxOffsetBeats) {
                defaultCanonSettings.maxOffsetBeats = payload.maxOffsetBeats;
            }
            const minSlider = document.getElementById('canon-min-offset');
            const maxSlider = document.getElementById('canon-max-offset');
            if (minSlider) {
                const maxForMin = Math.max(1, Math.min(64, Math.max(1, Math.floor((beats - 1) / 2))));
                minSlider.max = Math.max(1, maxForMin);
                const minValue = Math.min(payload.minOffsetBeats || defaultCanonSettings.minOffsetBeats, maxForMin);
                minSlider.value = minValue;
                minSlider.dispatchEvent(new Event('input', { bubbles: true }));
            }
            if (maxSlider) {
                const cap = beats > 0 ? Math.max(2, beats - 1) : defaultCanonSettings.maxOffsetBeats;
                maxSlider.max = cap;
                const minCandidate = Math.max(2, Math.min(8, cap - 1));
                let minSetting = Math.min(minCandidate, cap - 1);
                if (minSetting >= cap) {
                    minSetting = Math.max(2, cap - 1);
                }
                maxSlider.min = Math.max(2, minSetting);
                const maxValue = Math.min(payload.maxOffsetBeats || defaultCanonSettings.maxOffsetBeats, cap);
                maxSlider.value = maxValue;
                maxSlider.dispatchEvent(new Event('input', { bubbles: true }));
            }
            const currentAdvanced = typeof window.isCanonAdvancedEnabled === 'function' ? window.isCanonAdvancedEnabled() : false;
            setCanonControlsEnabled(currentAdvanced);
            if (canonAdvancedToggle) {
                canonAdvancedToggle.checked = currentAdvanced;
            }
        };

        window.onCanonModeChanged = (enabled) => {
            setCanonControlsEnabled(enabled);
            if (canonAdvancedToggle) {
                canonAdvancedToggle.checked = !!enabled;
            }
        };

        // helper to clear params when browser back/forward is used
        window.addEventListener('popstate', () => {
            const params = new URLSearchParams(window.location.search);
            if (!params.has('trid')) {
                setState('state-home');
                if (driver && typeof driver.stop === "function") {
                    driver.stop();
                }
            }
        });
    })();
    </script>
</body>
</html>

