<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Harmonizer Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='modern.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='visualizer.css') }}">
</head>
<body class="page {% if track_id %}state-player{% else %}state-home{% endif %} advanced-collapsed" data-mode="{{ mode }}">
    <div class="music-field" aria-hidden="true">
        <div class="music track one"><span></span><span></span><span></span><span></span><span></span></div>
        <div class="music track two"><span></span><span></span><span></span><span></span><span></span></div>
        <div class="music track three"><span></span><span></span><span></span><span></span><span></span></div>
    </div>

    <div class="page-shell">
        <a href="/" class="back-button hidden" id="back-button" aria-label="Back to song select"><span aria-hidden="true">&#8592;</span><span class="back-button-label">Back</span></a>
        <header class="hero">
            <div class="hero-meta">
                <div class="badge">Harmonizer Lab</div>
                <h1>Canonize any track</h1>
                <p>Upload audio or paste a link, then shape the canon live.</p>
            </div>
        </header>

        <main class="layout">
            <section class="panel intake-panel" id="intake-panel">
                <h2>Load A Track</h2>
                <form id="process-form" enctype="multipart/form-data" novalidate>
                    <div class="section-title">Engine</div>
                    <div class="toggle-group" id="algorithm-toggle">
                        <button type="button" data-algorithm="canon" class="toggle active">Autocanonizer</button>
                        <button type="button" data-algorithm="jukebox" class="toggle">Eternal Jukebox</button>
                        <button type="button" data-algorithm="eternal" class="toggle">Eternal Canonizer</button>
                    </div>
                    <input type="hidden" name="algorithm" value="canon" id="algorithm-input">

                    <div class="section-title">Source</div>
                    <div class="toggle-group" id="source-toggle">
                        <button type="button" data-source="upload" class="toggle active">Upload Audio</button>
                        <button type="button" data-source="youtube" class="toggle">YouTube</button>
                    </div>
                    <input type="hidden" name="source" value="upload" id="source-input">

                    <div class="source-pane" id="upload-pane">
                        <label class="field">
                            <span>Audio file</span>
                            <input type="file" name="audio" accept="audio/*">
                        </label>
                    </div>

                    <div class="source-pane hidden" id="youtube-pane">
                        <label class="field">
                            <span>YouTube link</span>
                            <input type="url" name="youtube_url" placeholder="https://www.youtube.com/watch?v=...">
                        </label>
                    </div>

                    <div class="metadata-grid">
                        <label class="field">
                            <span>Title <small>(optional)</small></span>
                            <input type="text" name="title" placeholder="Auto-detected when possible">
                        </label>
                        <label class="field">
                            <span>Artist <small>(optional)</small></span>
                            <input type="text" name="artist" placeholder="Auto-detected when possible">
                        </label>
                    </div>

                    <button type="submit" class="cta">Transform Track</button>
                </form>
                <div id="form-status" class="status-panel" role="status" aria-live="polite"></div>
                <div class="tips">
                    <p>Requires <code>ffmpeg</code> for YouTube imports.</p>
                </div>
            </section>

            <section class="panel viz-panel music-frame" id="viz-panel">
                <header class="viz-header">
                    <div class="viz-headline">
                        <h2>Visualizer</h2>
                        <p id="info"></p>
                    </div>
                    <div class="viz-actions">
                        <button id="play" class="viz-button">Play</button>
                        <span class="viz-timer" id="mtime">00:00:00</span>
                        <span class="viz-mode-pill" id="mode-pill">
                            {% if mode == 'jukebox' %}
                                Eternal Jukebox
                            {% elif mode == 'eternal' %}
                                Eternal Canonizer
                            {% else %}
                                Autocanonizer
                            {% endif %}
                        </span>
                        <button type="button" id="advanced-toggle" class="viz-button ghost advanced-toggle-button" aria-pressed="false">
                            Advanced: Off
                        </button>
                    </div>
                </header>
                <div class="viz-body">
                    <div class="viz-stage">
                        <div class="viz-status" id="status-panel"></div>
                        <div id="error"></div>
                        <div id="tiles" class="tiles-canvas"></div>
                        <footer class="viz-footer">
                            Press space to toggle playback - drag the window to reposition
                        </footer>
                    </div>
                    <aside class="viz-sidebar hidden" id="advanced-sidebar">
                        <div class="advanced-shell" id="advanced-shell">
                            <header class="advanced-header">
                                <h3>Advanced Settings</h3>
                                <p>Fine-tune how each engine behaves. Changes apply immediately.</p>
                            </header>
                            <div class="advanced-sections" id="advanced-sections"></div>
                        </div>
                    </aside>
                </div>
            </section>
        </main>

        <footer class="footer">
            Â© Harmonizer Lab
        </footer>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.3/jquery-ui.min.js"></script>
    <script src="{{ url_for('static', filename='js/underscore-min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/raphael-min.js') }}"></script>
    <script src="{{ url_for('static', filename='jremix.js') }}"></script>
    <script src="{{ url_for('static', filename='js/visualizer.js') }}"></script>
    <script>
    (function() {
        const body = document.body;
        const vizPanelElement = document.getElementById('viz-panel');
        const algorithmToggle = document.getElementById('algorithm-toggle');
        const sourceToggle = document.getElementById('source-toggle');
        const algorithmInput = document.getElementById('algorithm-input');
        const sourceInput = document.getElementById('source-input');
        const uploadPane = document.getElementById('upload-pane');
        const youtubePane = document.getElementById('youtube-pane');
        const form = document.getElementById('process-form');
        const statusPanel = document.getElementById('form-status');
        const modeFromBody = (body.dataset.mode || "canon").toLowerCase();
        let currentModeKey = modeFromBody;

        const setState = (state) => {
            body.classList.remove('state-home', 'state-player');
            body.classList.add(state);
            if (state === 'state-home' && vizPanelElement) {
                vizPanelElement.style.left = '';
                vizPanelElement.style.top = '';
                vizPanelElement.style.width = '';
                vizPanelElement.style.height = '';
            }
        };

        const backButton = document.getElementById('back-button');

        if ({{ 'true' if track_id else 'false' }}) {
            setState('state-player');
            if (backButton) {
                backButton.classList.remove('hidden');
                backButton.setAttribute('href', window.location.pathname + window.location.search.replace(/([?&])trid=[^&]*/g, '').replace(/^&/, '?'));
            }
        } else {
            if (backButton) { backButton.classList.add('hidden'); }
            setState('state-home');
        }

        function syncAlgorithmButtons(targetMode) {
            algorithmToggle.querySelectorAll('.toggle').forEach(btn => btn.classList.remove('active'));
            const match = algorithmToggle.querySelector('[data-algorithm=\"' + targetMode + '\"]');
            if (match) {
                match.classList.add('active');
                algorithmInput.value = targetMode;
            }
        }

        if (modeFromBody === "jukebox" || modeFromBody === "eternal" || modeFromBody === "canon") {
            syncAlgorithmButtons(modeFromBody);
        }

        algorithmToggle.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-algorithm]');
            if (!button) {
                return;
            }
            const targetMode = button.dataset.algorithm;
            syncAlgorithmButtons(targetMode);
            currentModeKey = (targetMode || '').toLowerCase();
            body.dataset.mode = targetMode;
            window.setAdvancedPanelMode(currentModeKey);
        });

        sourceToggle.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-source]');
            if (!button) {
                return;
            }
            sourceToggle.querySelectorAll('.toggle').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const source = button.dataset.source;
            sourceInput.value = source;
            if (source === 'upload') {
                uploadPane.classList.remove('hidden');
                youtubePane.classList.add('hidden');
            } else {
                youtubePane.classList.remove('hidden');
                uploadPane.classList.add('hidden');
            }
        });

        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            statusPanel.textContent = '';
            const source = sourceInput.value;
            if (source === 'upload') {
                const fileInput = form.querySelector('input[name="audio"]');
                if (!fileInput.files || fileInput.files.length === 0) {
                    statusPanel.textContent = 'Please choose an audio file to upload.';
                    return;
                }
            } else {
                const urlField = form.querySelector('input[name="youtube_url"]');
                if (!urlField.value) {
                    statusPanel.textContent = 'Please paste a YouTube link.';
                    return;
                }
            }

            const submitButton = form.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            submitButton.textContent = 'Processing...';
            statusPanel.textContent = 'Analyzing audio... this can take a minute.';

            try {
                const formData = new FormData(form);
                const response = await fetch('/api/process', {
                    method: 'POST',
                    body: formData
                });
                const payload = await response.json();
                if (!response.ok) {
                    throw new Error(payload.error || 'Something went wrong.');
                }
                statusPanel.textContent = 'Ready! Loading the visualizer...';
                window.location.href = payload.redirect;
            } catch (err) {
                statusPanel.textContent = err.message;
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Transform Track';
            }
        });

        const advancedToggleButton = document.getElementById('advanced-toggle');
        const advancedSidebar = document.getElementById('advanced-sidebar');
        const advancedShell = document.getElementById('advanced-shell');
        const advancedSectionsRoot = document.getElementById('advanced-sections');

        body.classList.add('advanced-collapsed');

        let advancedSidebarVisible = false;

        function updateAdvancedToggleState() {
            if (!advancedToggleButton) {
                return;
            }
            advancedToggleButton.setAttribute('aria-pressed', advancedSidebarVisible ? 'true' : 'false');
            advancedToggleButton.classList.toggle('active', advancedSidebarVisible);
            advancedToggleButton.textContent = advancedSidebarVisible ? 'Advanced: On' : 'Advanced: Off';
        }

        if (advancedSidebar) {
            advancedSidebar.classList.add('hidden');
            advancedSidebar.setAttribute('aria-hidden', 'true');
        }

        function showAdvancedSidebar() {
            if (!advancedSidebarVisible || !advancedSidebar) {
                return;
            }
            advancedSidebar.classList.remove('hidden');
            advancedSidebar.removeAttribute('aria-hidden');
        }

        function syncAdvancedUiForMode(modeKey) {
            if (!advancedSidebarVisible) {
                return;
            }
            const normalized = (modeKey || currentModeKey || 'canon').toLowerCase();
            currentModeKey = normalized;
            primeGroupLayoutForMode(currentModeKey);
            showAdvancedSidebar();
        }

        window.setCanonUiVisibility = (visible) => {
            if (visible && advancedSidebarVisible) {
                window.setAdvancedPanelMode('canon');
            }
        };

        window.setAdvancedPanelMode = (modeKey) => {
            const normalized = (modeKey || currentModeKey || 'canon').toLowerCase();
            currentModeKey = normalized;
            pendingAdvancedMode = normalized;
            if (!advancedSidebarVisible) {
                return;
            }
            ensureAdvancedUi();
            ensureModeDefaults(currentModeKey);
            syncAdvancedSectionsForMode(currentModeKey);
            syncAdvancedUiForMode(currentModeKey);
        };

        const ADVANCED_GROUP_METADATA = {
            canonOverlay: {
                title: 'Overlay Behaviour',
                description: 'Set spacing, dwell, and texture for the live Autocanonizer voices.',
                fields: [
                    { key: 'minOffsetBeats', label: 'Minimum Offset', min: 1, max: 96, step: 1, format: (v) => `${v} beats`, description: 'Earliest beat separation between overlay voices.' },
                    { key: 'maxOffsetBeats', label: 'Maximum Offset', min: 2, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Largest allowed beat offset between overlay voices.' },
                    { key: 'dwellBeats', label: 'Dwell', min: 1, max: 16, step: 1, format: (v) => `${v} beats`, description: 'Minimum beats to stay on a pairing before retargeting.' },
                    { key: 'density', label: 'Density', min: 1, max: 6, step: 1, format: (v) => `${v}/6`, description: 'Higher values add more simultaneous overlay voices.' },
                    { key: 'variation', label: 'Variation', min: 0, max: 10, step: 1, format: (v) => `${v}`, description: 'Controls how adventurous the overlay can be when rewiring connections.' }
                ]
            },
            jukeboxLoop: {
                title: 'Loop Pathing',
                description: 'Dial in how Eternal Jukebox picks loops and when it moves on.',
                fields: [
                    { key: 'minLoopBeats', label: 'Minimum Loop Length', min: 4, max: 64, step: 1, format: (v) => `${v} beats`, description: 'Shortest loop allowed when picking jump targets.' },
                    { key: 'maxSequentialBeats', label: 'Sequential Ceiling', min: 8, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Maximum beats to play before forcing a jump.' },
                    { key: 'loopThreshold', label: 'Similarity Threshold', min: 0.3, max: 0.95, step: 0.01, format: (v) => `${Math.round(v * 100)}%`, description: 'Higher values require closer similarity before a loop is accepted.' },
                    { key: 'sectionBias', label: 'Section Bias', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}% in-section`, description: 'Preference for staying within the same section when looping.' },
                    { key: 'jumpVariance', label: 'Jump Variance', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}%`, description: 'Higher values encourage varied jump timing; lower values keep loops tighter.' }
                ]
            },
            eternalOverlay: {
                title: 'Overlay Behaviour',
                description: 'Shape the multivoice overlay used in Eternal Canonizer mode.',
                fields: [
                    { key: 'minOffsetBeats', label: 'Minimum Offset', min: 1, max: 96, step: 1, format: (v) => `${v} beats`, description: 'Earliest beat separation for overlay voices.' },
                    { key: 'maxOffsetBeats', label: 'Maximum Offset', min: 2, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Largest beat separation for overlay voices.' },
                    { key: 'dwellBeats', label: 'Dwell', min: 1, max: 16, step: 1, format: (v) => `${v} beats`, description: 'Minimum beats before switching overlay targets.' },
                    { key: 'density', label: 'Density', min: 1, max: 6, step: 1, format: (v) => `${v}/6`, description: 'Higher values add thicker overlays.' },
                    { key: 'variation', label: 'Variation', min: 0, max: 10, step: 1, format: (v) => `${v}`, description: 'Controls how much the overlay may deviate from its base pattern.' }
                ]
            },
            eternalLoop: {
                title: 'Loop Pathing',
                description: 'Control loop behaviour when running the Eternal Canonizer.',
                fields: [
                    { key: 'minLoopBeats', label: 'Minimum Loop Length', min: 4, max: 64, step: 1, format: (v) => `${v} beats`, description: 'Shortest allowed loop when chaining canon segments.' },
                    { key: 'maxSequentialBeats', label: 'Sequential Ceiling', min: 8, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Maximum beats before forcing a jump to another segment.' },
                    { key: 'loopThreshold', label: 'Similarity Threshold', min: 0.3, max: 0.95, step: 0.01, format: (v) => `${Math.round(v * 100)}%`, description: 'Higher values require stronger similarity before loops are used.' },
                    { key: 'sectionBias', label: 'Section Bias', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}% in-section`, description: 'Controls how strongly the canon prefers staying within a section when looping.' },
                    { key: 'jumpVariance', label: 'Jump Variance', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}%`, description: 'Influences how surprising the loop timing can be.' }
                ]
            }
        };

        const ADVANCED_SECTION_LAYOUT = [
            {
                id: 'canon',
                label: 'Autocanonizer',
                summary: 'Control how the live canon overlay weaves through the track.',
                groups: ['canonOverlay']
            },
            {
                id: 'jukebox',
                label: 'Eternal Jukebox',
                summary: 'Shape how the jukebox chooses and times its infinite loops.',
                groups: ['jukeboxLoop']
            },
            {
                id: 'eternal',
                label: 'Eternal Canonizer',
                summary: 'Balance overlay density with the looping engine for long-form canons.',
                groups: ['eternalOverlay', 'eternalLoop']
            }
        ];

        const MODE_TO_SECTION_IDS = {
            canon: ['canon'],
            jukebox: ['jukebox'],
            eternal: ['eternal', 'canon', 'jukebox']
        };

        const advancedDomMap = Object.create(null);
        const advancedSectionNodes = Object.create(null);
        let advancedUiReady = false;
        let pendingAdvancedMode = currentModeKey;

        const MODE_PRIMARY_GROUPS = {
            canon: ['canonOverlay'],
            jukebox: ['jukeboxLoop'],
            eternal: ['eternalOverlay', 'eternalLoop']
        };

        function buildAdvancedUi() {
            if (!advancedSidebar || !advancedShell || !advancedSectionsRoot) {
                return;
            }
            if (typeof window.getAdvancedSettings !== 'function' || typeof window.updateAdvancedGroupSetting !== 'function') {
                return;
            }

            advancedSectionsRoot.innerHTML = '';
            Object.keys(advancedDomMap).forEach((key) => { delete advancedDomMap[key]; });
            Object.keys(advancedSectionNodes).forEach((key) => { delete advancedSectionNodes[key]; });

            ADVANCED_SECTION_LAYOUT.forEach((sectionConfig) => {
                const sectionNode = document.createElement('section');
                sectionNode.className = 'advanced-section';
                sectionNode.dataset.sectionMode = sectionConfig.id;

                const sectionHeader = document.createElement('header');
                sectionHeader.className = 'advanced-section-header';

                const headerTitle = document.createElement('h4');
                headerTitle.textContent = sectionConfig.label;
                sectionHeader.appendChild(headerTitle);

                if (sectionConfig.summary) {
                    const summaryNode = document.createElement('p');
                    summaryNode.className = 'advanced-section-summary';
                    summaryNode.textContent = sectionConfig.summary;
                    sectionHeader.appendChild(summaryNode);
                }

                sectionNode.appendChild(sectionHeader);

                sectionConfig.groups.forEach((groupKey) => {
                    const meta = ADVANCED_GROUP_METADATA[groupKey];
                    if (!meta) {
                        return;
                    }

                    const groupNode = document.createElement('article');
                    groupNode.className = 'advanced-group';
                    groupNode.dataset.groupKey = groupKey;

                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'advanced-group-header';

                    const titleNode = document.createElement('h5');
                    titleNode.className = 'advanced-group-title';
                    titleNode.textContent = meta.title;
                    groupHeader.appendChild(titleNode);

                    const collapseButton = document.createElement('button');
                    collapseButton.type = 'button';
                    collapseButton.className = 'advanced-collapse-btn';
                    collapseButton.setAttribute('aria-label', `Toggle ${meta.title} settings`);
                    collapseButton.setAttribute('aria-expanded', 'false');
                    collapseButton.innerHTML = '<span class="chevron"></span>';

                    const toggleLabel = document.createElement('label');
                    toggleLabel.className = 'advanced-group-toggle';

                    const toggle = document.createElement('input');
                    toggle.type = 'checkbox';
                    toggle.dataset.groupKey = groupKey;
                    toggle.id = `advanced-toggle-${groupKey}`;
                    toggleLabel.appendChild(toggle);

                    const toggleText = document.createElement('span');
                    toggleText.textContent = 'Enable custom settings';
                    toggleLabel.appendChild(toggleText);

                    groupHeader.appendChild(toggleLabel);
                    groupHeader.appendChild(collapseButton);
                    groupNode.appendChild(groupHeader);

                    const bodyWrapper = document.createElement('div');
                    bodyWrapper.className = 'advanced-group-body';
                    groupNode.appendChild(bodyWrapper);

                    if (meta.description) {
                        const descriptionNode = document.createElement('p');
                        descriptionNode.className = 'advanced-group-description';
                        descriptionNode.textContent = meta.description;
                        bodyWrapper.appendChild(descriptionNode);
                    }

                    const fieldsContainer = document.createElement('div');
                    fieldsContainer.className = 'advanced-fields';
                    bodyWrapper.appendChild(fieldsContainer);

                    const inputs = Object.create(null);
                    const valueLabels = Object.create(null);
                    const fieldMeta = Object.create(null);

                    meta.fields.forEach((field) => {
                        const control = document.createElement('div');
                        control.className = 'advanced-control';

                        const topLine = document.createElement('div');
                        topLine.className = 'advanced-control-topline';

                        const labelNode = document.createElement('label');
                        labelNode.className = 'advanced-control-label';
                        labelNode.htmlFor = `advanced-${groupKey}-${field.key}`;
                        labelNode.textContent = field.label;
                        topLine.appendChild(labelNode);

                        const valueNode = document.createElement('span');
                        valueNode.className = 'advanced-control-value';
                        topLine.appendChild(valueNode);

                        control.appendChild(topLine);

                        const input = document.createElement('input');
                        input.type = 'range';
                        input.min = field.min;
                        input.max = field.max;
                        if (field.step !== undefined) {
                            input.step = field.step;
                        } else if (field.max - field.min <= 1) {
                            input.step = 0.01;
                        }
                        input.id = `advanced-${groupKey}-${field.key}`;
                        input.dataset.groupKey = groupKey;
                        input.dataset.fieldKey = field.key;

                        control.appendChild(input);

                        if (field.description) {
                            const hint = document.createElement('p');
                            hint.className = 'advanced-control-hint';
                            hint.textContent = field.description;
                            control.appendChild(hint);
                        }

                        fieldsContainer.appendChild(control);

                        inputs[field.key] = input;
                        valueLabels[field.key] = valueNode;
                        fieldMeta[field.key] = field;

                        input.addEventListener('input', handleAdvancedFieldInput);
                        input.addEventListener('change', handleAdvancedFieldCommit);
                    });

                    const resetButton = document.createElement('button');
                    resetButton.type = 'button';
                    resetButton.className = 'viz-button ghost advanced-reset-button';
                    resetButton.dataset.groupKey = groupKey;
                    resetButton.textContent = 'Reset to defaults';
                    resetButton.addEventListener('click', handleAdvancedReset);
                    bodyWrapper.appendChild(resetButton);

                    toggle.addEventListener('change', handleAdvancedToggle);

                    advancedDomMap[groupKey] = {
                        groupNode,
                        toggle,
                        body: bodyWrapper,
                        collapseButton,
                        inputs,
                        valueLabels,
                        fieldMeta,
                        resetButton,
                        fieldsContainer
                    };

                    collapseButton.addEventListener('click', () => {
                        const dom = advancedDomMap[groupKey];
                        if (!dom) {
                            return;
                        }
                        const collapsed = dom.groupNode.classList.contains('is-collapsed');
                        setGroupCollapsed(groupKey, !collapsed);
                    });

                    sectionNode.appendChild(groupNode);
                    setGroupCollapsed(groupKey, true);
                });

                advancedSectionsRoot.appendChild(sectionNode);
                advancedSectionNodes[sectionConfig.id] = sectionNode;
            });

            Object.keys(ADVANCED_GROUP_METADATA).forEach((groupKey) => {
                syncGroupFromState(groupKey);
            });

            advancedUiReady = true;
            window.setAdvancedPanelMode(pendingAdvancedMode);
        }

        function ensureAdvancedUi() {
            if (advancedUiReady) {
                return;
            }
            buildAdvancedUi();
        }

        function disableAllAdvancedGroups() {
            if (!advancedUiReady) {
                return;
            }
            Object.keys(ADVANCED_GROUP_METADATA).forEach((groupKey) => {
                if (isGroupEnabled(groupKey)) {
                    setGroupEnabled(groupKey, false);
                }
                setGroupInputsDisabled(groupKey, true);
                setGroupCollapsed(groupKey, true);
                const dom = advancedDomMap[groupKey];
                if (dom && dom.toggle) {
                    dom.toggle.checked = false;
                }
            });
        }

        function setAdvancedVisibility(enabled) {
            const normalized = !!enabled;
            if (normalized === advancedSidebarVisible) {
                updateAdvancedToggleState();
                return;
            }
            advancedSidebarVisible = normalized;
            body.classList.toggle('advanced-expanded', normalized);
            body.classList.toggle('advanced-collapsed', !normalized);
            updateAdvancedToggleState();
            if (normalized) {
                ensureAdvancedUi();
                ensureModeDefaults(currentModeKey);
                showAdvancedSidebar();
                window.setAdvancedPanelMode(currentModeKey);
            } else if (advancedSidebar) {
                disableAllAdvancedGroups();
                advancedSidebar.classList.add('hidden');
                advancedSidebar.setAttribute('aria-hidden', 'true');
            }
        }

        function handleAdvancedToggle(event) {
            const checkbox = event.currentTarget;
            const groupKey = checkbox && checkbox.dataset ? checkbox.dataset.groupKey : null;
            if (!groupKey) {
                return;
            }
        const enabled = checkbox.checked;
        setGroupEnabled(groupKey, enabled);
        setGroupInputsDisabled(groupKey, !enabled);
        syncGroupFromState(groupKey);
        if (enabled) {
            setGroupCollapsed(groupKey, false);
            scheduleAdvancedApply(groupKey, 'toggle');
        } else {
            setGroupCollapsed(groupKey, true);
        }
    }

        function handleAdvancedFieldInput(event) {
            const input = event.currentTarget;
            const groupKey = input && input.dataset ? input.dataset.groupKey : null;
            const fieldKey = input && input.dataset ? input.dataset.fieldKey : null;
            if (!groupKey || !fieldKey) {
                return;
            }
            const value = parseFloat(input.value);
            if (Number.isNaN(value)) {
                return;
            }
            updateValueLabel(groupKey, fieldKey, value);
            enforceGroupConstraints(groupKey);
        }

        function handleAdvancedFieldCommit(event) {
            const input = event.currentTarget;
            const groupKey = input && input.dataset ? input.dataset.groupKey : null;
            const fieldKey = input && input.dataset ? input.dataset.fieldKey : null;
            if (!groupKey || !fieldKey) {
                return;
            }
            const value = parseFloat(input.value);
            if (Number.isNaN(value)) {
                return;
            }
            if (typeof window.applyImmediateAdvancedSetting === 'function') {
                window.applyImmediateAdvancedSetting(groupKey, fieldKey, value);
            } else {
                if (typeof window.setAdvancedGroupEnabled === 'function') {
                    window.setAdvancedGroupEnabled(groupKey, true);
                }
                if (typeof window.updateAdvancedGroupSetting === 'function') {
                    window.updateAdvancedGroupSetting(groupKey, fieldKey, value);
                }
                if (typeof window.applyAdvancedGroup === 'function') {
                    window.applyAdvancedGroup(groupKey, { source: 'ui' });
                }
            }
            syncGroupFromState(groupKey);
            updateValueLabel(groupKey, fieldKey, value);
            enforceGroupConstraints(groupKey);
        }

        function handleAdvancedReset(event) {
            const button = event.currentTarget;
            const groupKey = button && button.dataset ? button.dataset.groupKey : null;
            if (!groupKey || typeof window.resetAdvancedGroup !== 'function') {
                return;
            }
            window.resetAdvancedGroup(groupKey);
            syncGroupFromState(groupKey);
            if (typeof window.applyAdvancedGroup !== 'function') {
                return;
            }
            window.applyAdvancedGroup(groupKey, { source: 'reset' });
        }

        function setGroupEnabled(groupKey, enabled) {
            if (!groupKey) {
                return;
            }
            if (groupKey === 'canonOverlay' && typeof window.setCanonAdvancedEnabled === 'function') {
                window.setCanonAdvancedEnabled(enabled);
            } else if (groupKey === 'eternalOverlay' && typeof window.setEternalAdvancedEnabled === 'function') {
                window.setEternalAdvancedEnabled(enabled);
            } else if (typeof window.setAdvancedGroupEnabled === 'function') {
                window.setAdvancedGroupEnabled(groupKey, enabled);
            }
        }

        function isGroupEnabled(groupKey) {
            if (groupKey === 'canonOverlay' && typeof window.isCanonAdvancedEnabled === 'function') {
                return !!window.isCanonAdvancedEnabled();
            }
            if (groupKey === 'eternalOverlay' && typeof window.isEternalAdvancedEnabled === 'function') {
                return !!window.isEternalAdvancedEnabled();
            }
            const state = getGroupState(groupKey);
            return state ? !!state.enabled : false;
        }

        function getGroupState(groupKey) {
            if (typeof window.getAdvancedSettings !== 'function') {
                return null;
            }
            try {
                return window.getAdvancedSettings(groupKey);
            } catch (err) {
                return null;
            }
        }

        function updateGroupToggleState(groupKey, enabled) {
            const dom = advancedDomMap[groupKey];
            if (!dom || !dom.toggle) {
                return;
            }
            dom.toggle.checked = !!enabled;
            setGroupInputsDisabled(groupKey, !enabled);
        }

        function setGroupInputsDisabled(groupKey, disabled) {
            const dom = advancedDomMap[groupKey];
            if (!dom) {
                return;
            }
            const disabledFlag = !!disabled && !advancedSidebarVisible;
            Object.values(dom.inputs).forEach((input) => {
                input.disabled = disabledFlag;
            });
            if (dom.resetButton) {
                dom.resetButton.disabled = disabledFlag;
            }
            if (dom.groupNode) {
                dom.groupNode.classList.toggle('is-disabled', disabledFlag);
                dom.groupNode.setAttribute('aria-disabled', disabledFlag ? 'true' : 'false');
            }
        }

    function setGroupCollapsed(groupKey, collapsed) {
        const dom = advancedDomMap[groupKey];
        if (!dom) {
            return;
        }
        const collapseFlag = !!collapsed;
        dom.groupNode.classList.toggle('is-collapsed', collapseFlag);
        if (dom.body) {
            dom.body.hidden = collapseFlag;
        }
        if (dom.collapseButton) {
            dom.collapseButton.setAttribute('aria-expanded', collapseFlag ? 'false' : 'true');
        }
    }

    function primeGroupLayoutForMode(modeKey) {
        if (!advancedUiReady) {
            return;
        }
        const normalized = (modeKey || '').toLowerCase();
        let expandedGroups = [];
        if (normalized === 'canon') {
            expandedGroups = ['canonOverlay'];
        } else if (normalized === 'jukebox') {
            expandedGroups = ['jukeboxLoop'];
        } else if (normalized === 'eternal') {
            expandedGroups = ['eternalOverlay', 'eternalLoop'];
        }
        Object.keys(ADVANCED_GROUP_METADATA).forEach((groupKey) => {
            const shouldExpand = expandedGroups.includes(groupKey);
            setGroupCollapsed(groupKey, !shouldExpand);
        });
    }

        function ensureModeDefaults(modeKey) {
            if (!advancedUiReady) {
                return;
            }
            const normalized = (modeKey || '').toLowerCase();
            const primaryGroups = MODE_PRIMARY_GROUPS[normalized] || [];
            primaryGroups.forEach((groupKey, index) => {
                if (!isGroupEnabled(groupKey)) {
                    setGroupEnabled(groupKey, true);
                }
                const dom = advancedDomMap[groupKey];
                if (dom) {
                    if (dom.toggle) {
                        dom.toggle.checked = true;
                    }
                    setGroupInputsDisabled(groupKey, false);
                }
                syncGroupFromState(groupKey);
                if (index === 0) {
                    setGroupCollapsed(groupKey, false);
                }
            });
        }

        function syncGroupFromState(groupKey) {
            const dom = advancedDomMap[groupKey];
            if (!dom) {
                return;
            }
            const state = getGroupState(groupKey);
            const defaults = state && state.defaults ? state.defaults : {};
            const settings = state && state.settings ? state.settings : defaults;
            const enabled = state ? !!state.enabled : false;
            updateGroupToggleState(groupKey, enabled);
            Object.entries(dom.inputs).forEach(([fieldKey, input]) => {
                const nextValue = settings && settings[fieldKey] !== undefined ? settings[fieldKey] : defaults[fieldKey];
                if (nextValue !== undefined) {
                    input.value = nextValue;
                }
                updateValueLabel(groupKey, fieldKey, parseFloat(input.value));
            });
            enforceGroupConstraints(groupKey);
        }

        function updateValueLabel(groupKey, fieldKey, value) {
            const dom = advancedDomMap[groupKey];
            if (!dom || !dom.valueLabels[fieldKey]) {
                return;
            }
            const field = dom.fieldMeta[fieldKey];
            dom.valueLabels[fieldKey].textContent = formatFieldValue(value, field);
        }

        function formatFieldValue(value, field) {
            if (field && typeof field.format === 'function') {
                return field.format(value);
            }
            if (typeof value === 'number' && value % 1 !== 0) {
                return value.toFixed(2);
            }
            return `${value}`;
        }

        function enforceGroupConstraints(groupKey) {
            const dom = advancedDomMap[groupKey];
            if (!dom) {
                return;
            }
            if (groupKey === 'canonOverlay' || groupKey === 'eternalOverlay') {
                const minInput = dom.inputs.minOffsetBeats;
                const maxInput = dom.inputs.maxOffsetBeats;
                if (minInput && maxInput) {
                    const minValue = parseInt(minInput.value, 10) || 1;
                    const minForMax = Math.max(minValue + 1, parseInt(maxInput.min, 10) || minValue + 1);
                    maxInput.min = minForMax;
                    let maxValue = parseInt(maxInput.value, 10) || minForMax;
                    if (maxValue <= minValue) {
                        maxValue = minForMax;
                        maxInput.value = String(maxValue);
                        if (typeof window.updateAdvancedGroupSetting === 'function') {
                            window.updateAdvancedGroupSetting(groupKey, 'maxOffsetBeats', maxValue);
                        }
                    }
                    updateValueLabel(groupKey, 'maxOffsetBeats', parseFloat(maxInput.value));
                }
            } else if (groupKey === 'jukeboxLoop' || groupKey === 'eternalLoop') {
                const minLoopInput = dom.inputs.minLoopBeats;
                const maxSeqInput = dom.inputs.maxSequentialBeats;
                if (minLoopInput && maxSeqInput) {
                    const minLoop = parseInt(minLoopInput.value, 10) || 4;
                    const minSeq = Math.max(minLoop + 2, parseInt(maxSeqInput.min, 10) || (minLoop + 2));
                    maxSeqInput.min = minSeq;
                    let maxSeq = parseInt(maxSeqInput.value, 10) || minSeq;
                    if (maxSeq <= minLoop) {
                        maxSeq = minSeq;
                        maxSeqInput.value = String(maxSeq);
                        if (typeof window.updateAdvancedGroupSetting === 'function') {
                            window.updateAdvancedGroupSetting(groupKey, 'maxSequentialBeats', maxSeq);
                        }
                    }
                    updateValueLabel(groupKey, 'maxSequentialBeats', parseFloat(maxSeqInput.value));
                }
            }
        }

        function syncAdvancedSectionsForMode(modeKey) {
            pendingAdvancedMode = modeKey;
            if (!advancedUiReady) {
                return;
            }
            const allowed = MODE_TO_SECTION_IDS[modeKey] || [];
            const selection = allowed.length ? allowed : ADVANCED_SECTION_LAYOUT.map((section) => section.id);
            const allowedSet = new Set(selection);
            ADVANCED_SECTION_LAYOUT.forEach((section) => {
                const node = advancedSectionNodes[section.id];
                if (node) {
                    node.classList.toggle('hidden', !allowedSet.has(section.id));
                }
            });
            primeGroupLayoutForMode(modeKey);
        }

        window.onCanonModeChanged = (enabled) => {
            if (!advancedSidebarVisible) {
                return;
            }
            updateGroupToggleState('canonOverlay', enabled);
            syncGroupFromState('canonOverlay');
            if (enabled) {
                setGroupCollapsed('canonOverlay', false);
            }
        };

        setAdvancedVisibility(false);
        if (advancedToggleButton) {
            advancedToggleButton.addEventListener('click', () => {
                setAdvancedVisibility(!advancedSidebarVisible);
            });
        }



        // helper to clear params when browser back/forward is used
        window.addEventListener('popstate', () => {
            if (backButton) { backButton.classList.add('hidden'); }
            const params = new URLSearchParams(window.location.search);
            if (!params.has('trid')) {
                setState('state-home');
                if (driver && typeof driver.stop === "function") {
                    driver.stop();
                }
            }
        });
    })();
    </script>
</body>
</html>

