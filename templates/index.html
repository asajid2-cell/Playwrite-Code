<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Harmonizer Lab</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Manrope:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='modern.css') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='visualizer.css') }}">
</head>
<body class="page {% if track_id %}state-player{% else %}state-home{% endif %}" data-mode="{{ mode }}">
    <div class="music-field" aria-hidden="true">
        <div class="music track one"><span></span><span></span><span></span><span></span><span></span></div>
        <div class="music track two"><span></span><span></span><span></span><span></span><span></span></div>
        <div class="music track three"><span></span><span></span><span></span><span></span><span></span></div>
    </div>

    <div class="page-shell">
        <header class="hero">
            <div class="hero-meta">
                <div class="badge">Harmonizer Lab</div>
                <h1>Canonize any track</h1>
                <p>Upload audio or paste a link, then shape the canon live.</p>
            </div>
        </header>

        <main class="layout">
            <section class="panel intake-panel" id="intake-panel">
                <h2>Load A Track</h2>
                <form id="process-form" enctype="multipart/form-data" novalidate>
                    <div class="section-title">Engine</div>
                    <div class="toggle-group" id="algorithm-toggle">
                        <button type="button" data-algorithm="canon" class="toggle active">Autocanonizer</button>
                        <button type="button" data-algorithm="jukebox" class="toggle">Eternal Jukebox</button>
                        <button type="button" data-algorithm="eternal" class="toggle">Eternal Canonizer</button>
                    </div>
                    <input type="hidden" name="algorithm" value="canon" id="algorithm-input">

                    <div class="section-title">Source</div>
                    <div class="toggle-group" id="source-toggle">
                        <button type="button" data-source="upload" class="toggle active">Upload Audio</button>
                        <button type="button" data-source="youtube" class="toggle">YouTube</button>
                    </div>
                    <input type="hidden" name="source" value="upload" id="source-input">

                    <div class="source-pane" id="upload-pane">
                        <label class="field">
                            <span>Audio file</span>
                            <input type="file" name="audio" accept="audio/*">
                        </label>
                    </div>

                    <div class="source-pane hidden" id="youtube-pane">
                        <label class="field">
                            <span>YouTube link</span>
                            <input type="url" name="youtube_url" placeholder="https://www.youtube.com/watch?v=...">
                        </label>
                    </div>

                    <div class="metadata-grid">
                        <label class="field">
                            <span>Title <small>(optional)</small></span>
                            <input type="text" name="title" placeholder="Auto-detected when possible">
                        </label>
                        <label class="field">
                            <span>Artist <small>(optional)</small></span>
                            <input type="text" name="artist" placeholder="Auto-detected when possible">
                        </label>
                    </div>

                    <button type="submit" class="cta">Transform Track</button>
                </form>
                <div id="form-status" class="status-panel" role="status" aria-live="polite"></div>
                <div class="tips">
                    <p>Requires <code>ffmpeg</code> for YouTube imports.</p>
                </div>
            </section>

            <section class="panel viz-panel music-frame" id="viz-panel">
                <header class="viz-header">
                    <div class="viz-headline">
                        <h2>Visualizer</h2>
                        <p id="info"></p>
                    </div>
                    <div class="viz-actions">
                        <button id="play" class="viz-button">Play</button>
                        <span class="viz-timer" id="mtime">00:00:00</span>
                        <span class="viz-mode-pill" id="mode-pill">
                            {% if mode == 'jukebox' %}
                                Eternal Jukebox
                            {% elif mode == 'eternal' %}
                                Eternal Canonizer
                            {% else %}
                                Autocanonizer
                            {% endif %}
                        </span>
                    </div>
                </header>
                <div class="viz-body">
                    <div class="viz-stage">
                        <div id="canon-sidebar" class="canon-sidebar hidden">
                            <div id="canon-controls" class="viz-tuning hidden">
                                <button type="button" id="canon-settings-toggle" class="viz-button ghost">Canon Controls</button>
                                <button type="button" id="canon-regenerate" class="viz-button ghost">Regenerate</button>
                                <button type="button" id="canon-reset" class="viz-button ghost">Reset</button>
                            </div>
                            <div id="canon-settings-panel" class="canon-settings-panel hidden" aria-hidden="true">
                                <div class="canon-setting-row">
                                    <label for="canon-min-offset">Min Offset</label>
                                    <input type="range" id="canon-min-offset" min="1" max="32" step="1" value="8">
                                    <span class="canon-setting-value" data-setting-display="minOffsetBeats">8 beats</span>
                                </div>
                                <div class="canon-setting-row">
                                    <label for="canon-max-offset">Max Offset</label>
                                    <input type="range" id="canon-max-offset" min="8" max="96" step="1" value="64">
                                    <span class="canon-setting-value" data-setting-display="maxOffsetBeats">64 beats</span>
                                </div>
                                <div class="canon-setting-row">
                                    <label for="canon-dwell">Hold Duration</label>
                                    <input type="range" id="canon-dwell" min="1" max="16" step="1" value="6">
                                    <span class="canon-setting-value" data-setting-display="dwellBeats">6 beats</span>
                                </div>
                                <div class="canon-setting-row">
                                    <label for="canon-density">Texture</label>
                                    <input type="range" id="canon-density" min="1" max="5" step="1" value="2">
                                    <span class="canon-setting-value" data-setting-display="density">Light (2/5)</span>
                                </div>
                                <div class="canon-setting-row">
                                    <label for="canon-variation">Variation</label>
                                    <input type="range" id="canon-variation" min="0" max="6" step="1" value="2">
                                    <span class="canon-setting-value" data-setting-display="variation">2</span>
                                </div>
                                <p class="canon-settings-note">Adjust the canon voice in real-time. Tap Regenerate to explore alternate overlays without reloading your track.</p>
                            </div>
                        </div>
                        <div class="viz-status" id="status-panel"></div>
                        <div id="error"></div>
                        <div id="tiles" class="tiles-canvas"></div>
                        <footer class="viz-footer">
                            Press space to toggle playback · drag the window wider for detail
                        </footer>
                    </div>
                    <aside class="viz-sidebar hidden" id="advanced-sidebar">
                        <div id="advanced-controls-header" class="advanced-controls-header hidden">
                            <select id="advanced-group-select" class="advanced-group-select"></select>
                            <label class="advanced-mode-toggle">
                                <input type="checkbox" id="advanced-mode-toggle">
                                <span>Advanced mode</span>
                            </label>
                            <button type="button" id="advanced-apply" class="viz-button ghost">Apply</button>
                            <button type="button" id="advanced-reset" class="viz-button ghost">Reset</button>
                        </div>
                        <div id="advanced-settings-panel" class="advanced-settings-panel hidden" aria-hidden="true">
                            <div id="advanced-control-container" class="advanced-control-container"></div>
                            <div class="preset-panel">
                                <div class="preset-save-row">
                                    <input type="text" id="preset-name" placeholder="Preset name">
                                    <button type="button" id="preset-save" class="viz-button ghost">Save</button>
                                    <button type="button" id="preset-download" class="viz-button ghost">Download</button>
                                </div>
                                <div class="preset-import-row">
                                    <label class="preset-upload viz-button ghost">
                                        <input type="file" id="preset-upload" accept="application/json">
                                        Import
                                    </label>
                                </div>
                                <div id="preset-list" class="preset-list"></div>
                            </div>
                        </div>
                    </aside>
                </div>
            </section>
        </main>

        <footer class="footer">
            © Harmonizer Lab
        </footer>
    </div>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.3/jquery-ui.min.js"></script>
    <script src="{{ url_for('static', filename='js/underscore-min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/raphael-min.js') }}"></script>
    <script src="{{ url_for('static', filename='jremix.js') }}"></script>
    <script src="{{ url_for('static', filename='js/visualizer.js') }}"></script>
    <script>
    (function() {
        const body = document.body;
        const algorithmToggle = document.getElementById('algorithm-toggle');
        const sourceToggle = document.getElementById('source-toggle');
        const algorithmInput = document.getElementById('algorithm-input');
        const sourceInput = document.getElementById('source-input');
        const uploadPane = document.getElementById('upload-pane');
        const youtubePane = document.getElementById('youtube-pane');
        const form = document.getElementById('process-form');
        const statusPanel = document.getElementById('form-status');
        const modeFromBody = body.dataset.mode || "canon";

        const setState = (state) => {
            body.classList.remove('state-home', 'state-player');
            body.classList.add(state);
        };

        if ({{ 'true' if track_id else 'false' }}) {
            setState('state-player');
        } else {
            setState('state-home');
        }

        function syncAlgorithmButtons(targetMode) {
            algorithmToggle.querySelectorAll('.toggle').forEach(btn => btn.classList.remove('active'));
            const match = algorithmToggle.querySelector('[data-algorithm=\"' + targetMode + '\"]');
            if (match) {
                match.classList.add('active');
                algorithmInput.value = targetMode;
            }
        }

        if (modeFromBody === "jukebox" || modeFromBody === "eternal" || modeFromBody === "canon") {
            syncAlgorithmButtons(modeFromBody);
        }

        algorithmToggle.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-algorithm]');
            if (!button) {
                return;
            }
            syncAlgorithmButtons(button.dataset.algorithm);
        });

        sourceToggle.addEventListener('click', (event) => {
            const button = event.target.closest('button[data-source]');
            if (!button) {
                return;
            }
            sourceToggle.querySelectorAll('.toggle').forEach(btn => btn.classList.remove('active'));
            button.classList.add('active');
            const source = button.dataset.source;
            sourceInput.value = source;
            if (source === 'upload') {
                uploadPane.classList.remove('hidden');
                youtubePane.classList.add('hidden');
            } else {
                youtubePane.classList.remove('hidden');
                uploadPane.classList.add('hidden');
            }
        });

        form.addEventListener('submit', async (event) => {
            event.preventDefault();
            statusPanel.textContent = '';
            const source = sourceInput.value;
            if (source === 'upload') {
                const fileInput = form.querySelector('input[name="audio"]');
                if (!fileInput.files || fileInput.files.length === 0) {
                    statusPanel.textContent = 'Please choose an audio file to upload.';
                    return;
                }
            } else {
                const urlField = form.querySelector('input[name="youtube_url"]');
                if (!urlField.value) {
                    statusPanel.textContent = 'Please paste a YouTube link.';
                    return;
                }
            }

            const submitButton = form.querySelector('button[type="submit"]');
            submitButton.disabled = true;
            submitButton.textContent = 'Processing...';
            statusPanel.textContent = 'Analyzing audio... this can take a minute.';

            try {
                const formData = new FormData(form);
                const response = await fetch('/api/process', {
                    method: 'POST',
                    body: formData
                });
                const payload = await response.json();
                if (!response.ok) {
                    throw new Error(payload.error || 'Something went wrong.');
                }
                statusPanel.textContent = 'Ready! Loading the visualizer...';
                window.location.href = payload.redirect;
            } catch (err) {
                statusPanel.textContent = err.message;
            } finally {
                submitButton.disabled = false;
                submitButton.textContent = 'Transform Track';
            }
        });
        const canonSidebar = document.getElementById('canon-sidebar');
        const canonControls = document.getElementById('canon-controls');
        const canonPanel = document.getElementById('canon-settings-panel');
        const canonToggleBtn = document.getElementById('canon-settings-toggle');
        const canonRegenerateBtn = document.getElementById('canon-regenerate');
        const canonResetBtn = document.getElementById('canon-reset');
        const densityLabels = ['Sparse', 'Light', 'Balanced', 'Rich', 'Dense'];
        const defaultCanonSettings = {
            minOffsetBeats: 8,
            maxOffsetBeats: 64,
            dwellBeats: 6,
            density: 2,
            variation: 2
        };

        function connectSlider(id, key, formatter, defaultValue) {
            const input = document.getElementById(id);
            const display = document.querySelector(`[data-setting-display="${key}"]`);
            if (!input) {
                return;
            }
            const formatValue = formatter || ((val) => val);
            const updateDisplay = (val) => {
                if (display) {
                    display.textContent = formatValue(val);
                }
            };
            const parse = (val) => parseInt(val, 10) || 0;
            updateDisplay(parse(input.value));
            input.addEventListener('input', () => {
                const numeric = parse(input.value);
                updateDisplay(numeric);
                if (typeof window.updateCanonSetting === 'function') {
                    window.updateCanonSetting(key, numeric);
                }
            });
            if (defaultValue !== undefined) {
                const min = input.min ? parseInt(input.min, 10) : defaultValue;
                const max = input.max ? parseInt(input.max, 10) : defaultValue;
                const initial = Math.min(max, Math.max(min, defaultValue));
                input.value = initial;
                input.dispatchEvent(new Event('input', { bubbles: true }));
            }
        }

        connectSlider('canon-min-offset', 'minOffsetBeats', (v) => `${v} beats`, defaultCanonSettings.minOffsetBeats);
        connectSlider('canon-max-offset', 'maxOffsetBeats', (v) => `${v} beats`, defaultCanonSettings.maxOffsetBeats);
        connectSlider('canon-dwell', 'dwellBeats', (v) => `${v} beats`, defaultCanonSettings.dwellBeats);
        connectSlider('canon-density', 'density', (v) => {
            const index = Math.min(densityLabels.length - 1, Math.max(0, v - 1));
            return `${densityLabels[index]} (${v}/5)`;
        }, defaultCanonSettings.density);
        connectSlider('canon-variation', 'variation', (v) => v.toString(), defaultCanonSettings.variation);

        const minOffsetSlider = document.getElementById('canon-min-offset');
        const maxOffsetSlider = document.getElementById('canon-max-offset');
        if (minOffsetSlider && maxOffsetSlider) {
            const syncMaxMin = () => {
                const minVal = parseInt(minOffsetSlider.value, 10) || 1;
                const maxVal = parseInt(maxOffsetSlider.value, 10) || (minVal + 1);
                const newMin = Math.max(2, minVal + 1);
                maxOffsetSlider.min = newMin;
                if (maxVal <= minVal) {
                    maxOffsetSlider.value = newMin;
                    maxOffsetSlider.dispatchEvent(new Event('input', { bubbles: true }));
                }
            };
            minOffsetSlider.addEventListener('input', syncMaxMin);
            syncMaxMin();
        }

        const canonAdvancedToggle = document.getElementById('canon-advanced-toggle');
        const sliderElements = canonPanel ? Array.from(canonPanel.querySelectorAll('input[type="range"]')) : [];
        const controlButtons = [canonToggleBtn, canonRegenerateBtn, canonResetBtn];

        const setCanonControlsEnabled = (enabled) => {
            const allow = !!enabled;
            sliderElements.forEach((el) => {
                el.disabled = !allow;
            });
            controlButtons.forEach((btn) => {
                if (btn) {
                    btn.disabled = !allow;
                }
            });
            if (!allow && canonPanel) {
                canonPanel.classList.add('hidden');
                canonPanel.setAttribute('aria-hidden', 'true');
            }
        };

        setCanonControlsEnabled(false);

        if (canonAdvancedToggle) {
            canonAdvancedToggle.checked = typeof window.isCanonAdvancedEnabled === 'function' ? window.isCanonAdvancedEnabled() : false;
            canonAdvancedToggle.addEventListener('change', () => {
                const enabled = canonAdvancedToggle.checked;
                if (typeof window.setCanonAdvancedEnabled === 'function') {
                    window.setCanonAdvancedEnabled(enabled);
                }
            });
        }

        if (canonToggleBtn && canonPanel) {
            canonToggleBtn.addEventListener('click', () => {
                const isHidden = canonPanel.classList.toggle('hidden');
                canonPanel.setAttribute('aria-hidden', isHidden ? 'true' : 'false');
            });
        }

        if (canonRegenerateBtn) {
            canonRegenerateBtn.addEventListener('click', () => {
                if (typeof window.regenerateCanonMappingManually === 'function') {
                    window.regenerateCanonMappingManually();
                }
            });
        }

        if (canonResetBtn) {
            canonResetBtn.addEventListener('click', () => {
                const sliderMap = [
                    ['canon-min-offset', defaultCanonSettings.minOffsetBeats],
                    ['canon-max-offset', defaultCanonSettings.maxOffsetBeats],
                    ['canon-dwell', defaultCanonSettings.dwellBeats],
                    ['canon-density', defaultCanonSettings.density],
                    ['canon-variation', defaultCanonSettings.variation]
                ];
                sliderMap.forEach(([id, value]) => {
                    const slider = document.getElementById(id);
                    if (!slider) {
                        return;
                    }
                    const min = slider.min ? parseInt(slider.min, 10) : value;
                    const max = slider.max ? parseInt(slider.max, 10) : value;
                    const target = Math.min(max, Math.max(min, value));
                    slider.value = target;
                    slider.dispatchEvent(new Event('input', { bubbles: true }));
                });
            });
        }

        window.setCanonUiVisibility = (visible) => {
            if (!canonControls) {
                return;
            }
            if (canonSidebar) {
                canonSidebar.classList.toggle('hidden', !visible);
            }
            canonControls.classList.toggle('hidden', !visible);
            if (!visible && canonPanel) {
                canonPanel.classList.add('hidden');
                canonPanel.setAttribute('aria-hidden', 'true');
            }
            if (!visible) {
                setCanonControlsEnabled(false);
            } else {
                const current = typeof window.isCanonAdvancedEnabled === 'function' ? window.isCanonAdvancedEnabled() : false;
                setCanonControlsEnabled(current);
                if (canonAdvancedToggle) {
                    canonAdvancedToggle.checked = current;
                }
            }
        };

        window.onCanonTrackReady = (payload) => {
            if (!canonControls) {
                return;
            }
            if (!payload || !payload.beats) {
                if (canonSidebar) {
                    canonSidebar.classList.add('hidden');
                }
                canonControls.classList.add('hidden');
                if (canonPanel) {
                    canonPanel.classList.add('hidden');
                    canonPanel.setAttribute('aria-hidden', 'true');
                }
                setCanonControlsEnabled(false);
                return;
            }
            if (canonSidebar) {
                canonSidebar.classList.remove('hidden');
            }
            canonControls.classList.remove('hidden');
            const beats = payload.beats;
            if (payload.minOffsetBeats) {
                defaultCanonSettings.minOffsetBeats = payload.minOffsetBeats;
            }
            if (payload.maxOffsetBeats) {
                defaultCanonSettings.maxOffsetBeats = payload.maxOffsetBeats;
            }
            const minSlider = document.getElementById('canon-min-offset');
            const maxSlider = document.getElementById('canon-max-offset');
            if (minSlider) {
                const maxForMin = Math.max(1, Math.min(64, Math.max(1, Math.floor((beats - 1) / 2))));
                minSlider.max = Math.max(1, maxForMin);
                const minValue = Math.min(payload.minOffsetBeats || defaultCanonSettings.minOffsetBeats, maxForMin);
                minSlider.value = minValue;
                minSlider.dispatchEvent(new Event('input', { bubbles: true }));
            }
            if (maxSlider) {
                const cap = beats > 0 ? Math.max(2, beats - 1) : defaultCanonSettings.maxOffsetBeats;
                maxSlider.max = cap;
                const minCandidate = Math.max(2, Math.min(8, cap - 1));
                let minSetting = Math.min(minCandidate, cap - 1);
                if (minSetting >= cap) {
                    minSetting = Math.max(2, cap - 1);
                }
                maxSlider.min = Math.max(2, minSetting);
                const maxValue = Math.min(payload.maxOffsetBeats || defaultCanonSettings.maxOffsetBeats, cap);
                maxSlider.value = maxValue;
                maxSlider.dispatchEvent(new Event('input', { bubbles: true }));
            }
            const currentAdvanced = typeof window.isCanonAdvancedEnabled === 'function' ? window.isCanonAdvancedEnabled() : false;
            setCanonControlsEnabled(currentAdvanced);
            if (canonAdvancedToggle) {
                canonAdvancedToggle.checked = currentAdvanced;
            }
        };

        window.onCanonModeChanged = (enabled) => {
            setCanonControlsEnabled(enabled);
            if (canonAdvancedToggle) {
                canonAdvancedToggle.checked = !!enabled;
            }
        };

        const advancedSidebar = document.getElementById('advanced-sidebar');
        const advancedControlsHeader = document.getElementById('advanced-controls-header');
        const advancedGroupSelect = document.getElementById('advanced-group-select');
        const advancedModeToggle = document.getElementById('advanced-mode-toggle');
        const advancedApplyButton = document.getElementById('advanced-apply');
        const advancedResetButton = document.getElementById('advanced-reset');
        const advancedSettingsPanel = document.getElementById('advanced-settings-panel');
        const advancedContainer = document.getElementById('advanced-control-container');
        const presetNameInput = document.getElementById('preset-name');
        const presetSaveButton = document.getElementById('preset-save');
        const presetDownloadButton = document.getElementById('preset-download');
        const presetUploadInput = document.getElementById('preset-upload');
        const presetList = document.getElementById('preset-list');

        const advancedGroupConfig = {
            canonOverlay: {
                label: 'Autocanonizer Overlay',
                description: 'Tune how the canon overlay enters, how dense it is, and how much variation it allows.',
                fields: [
                    { key: 'minOffsetBeats', label: 'Minimum Offset', min: 1, max: 96, step: 1, format: (v) => `${v} beats`, description: 'Earliest beat separation between overlay voices.' },
                    { key: 'maxOffsetBeats', label: 'Maximum Offset', min: 2, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Largest allowed beat offset between overlay voices.' },
                    { key: 'dwellBeats', label: 'Dwell', min: 1, max: 16, step: 1, format: (v) => `${v} beats`, description: 'Minimum beats to remain on a pairing before retargeting.' },
                    { key: 'density', label: 'Density', min: 1, max: 6, step: 1, format: (v) => `${v}/6`, description: 'Higher values add more simultaneous overlay activity.' },
                    { key: 'variation', label: 'Variation', min: 0, max: 10, step: 1, format: (v) => `${v}`, description: 'Controls how adventurous the overlay can be when rewiring connections.' }
                ]
            },
            eternalOverlay: {
                label: 'Eternal Canonizer Overlay',
                description: 'Shape the multivoice overlay used in Eternal Canonizer mode.',
                fields: [
                    { key: 'minOffsetBeats', label: 'Minimum Offset', min: 1, max: 96, step: 1, format: (v) => `${v} beats`, description: 'Earliest beat separation for the overlay voices.' },
                    { key: 'maxOffsetBeats', label: 'Maximum Offset', min: 2, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Largest beat separation for overlay voices.' },
                    { key: 'dwellBeats', label: 'Dwell', min: 1, max: 16, step: 1, format: (v) => `${v} beats`, description: 'Minimum beats before switching overlay target.' },
                    { key: 'density', label: 'Density', min: 1, max: 6, step: 1, format: (v) => `${v}/6`, description: 'Higher values add thicker overlays.' },
                    { key: 'variation', label: 'Variation', min: 0, max: 10, step: 1, format: (v) => `${v}`, description: 'Controls how much the overlay may deviate from its base pattern.' }
                ]
            },
            jukeboxLoop: {
                label: 'Eternal Jukebox Loops',
                description: 'Adjust how the Eternal Jukebox chooses loops and when it jumps between sections.',
                fields: [
                    { key: 'minLoopBeats', label: 'Minimum Loop Length', min: 4, max: 64, step: 1, format: (v) => `${v} beats`, description: 'Shortest loop allowed when picking jump targets.' },
                    { key: 'maxSequentialBeats', label: 'Sequential Ceiling', min: 8, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Maximum beats to play before forcing a jump.' },
                    { key: 'loopThreshold', label: 'Similarity Threshold', min: 0.3, max: 0.95, step: 0.01, format: (v) => `${Math.round(v * 100)}%`, description: 'Higher values require closer similarity before a loop is accepted.' },
                    { key: 'sectionBias', label: 'Section Bias', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}% in-section`, description: 'Preference for staying within the same section when looping.' },
                    { key: 'jumpVariance', label: 'Jump Variance', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}%`, description: 'Higher values encourage varied jump timing; lower values keep loops tighter.' }
                ]
            },
            eternalLoop: {
                label: 'Eternal Canonizer Loops',
                description: 'Control loop behaviour when running the Eternal Canonizer.',
                fields: [
                    { key: 'minLoopBeats', label: 'Minimum Loop Length', min: 4, max: 64, step: 1, format: (v) => `${v} beats`, description: 'Shortest allowed loop when chaining canon segments.' },
                    { key: 'maxSequentialBeats', label: 'Sequential Ceiling', min: 8, max: 128, step: 1, format: (v) => `${v} beats`, description: 'Maximum beats to play before forcing a jump to another segment.' },
                    { key: 'loopThreshold', label: 'Similarity Threshold', min: 0.3, max: 0.95, step: 0.01, format: (v) => `${Math.round(v * 100)}%`, description: 'Higher values require stronger similarity before loops are used.' },
                    { key: 'sectionBias', label: 'Section Bias', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}% in-section`, description: 'Controls how strongly the canon prefers staying within a section when looping.' },
                    { key: 'jumpVariance', label: 'Jump Variance', min: 0, max: 1, step: 0.05, format: (v) => `${Math.round(v * 100)}%`, description: 'Influences how surprising the loop timing can be.' }
                ]
            }
        };

        let currentAdvancedGroup = 'canonOverlay';
        let advancedValueDisplays = {};
        let advancedDescriptionNode = null;

        if (advancedSidebar && advancedControlsHeader && advancedGroupSelect && typeof window.getAdvancedSettings === 'function') {
            initializeAdvancedSidebar();
        }

        function initializeAdvancedSidebar() {
            advancedSidebar.classList.remove('hidden');
            advancedControlsHeader.classList.remove('hidden');
            if (advancedSettingsPanel) {
                advancedSettingsPanel.classList.remove('hidden');
                if (!advancedDescriptionNode) {
                    advancedDescriptionNode = document.createElement('p');
                    advancedDescriptionNode.className = 'advanced-description';
                    advancedDescriptionNode.id = 'advanced-group-description';
                    advancedSettingsPanel.insertBefore(advancedDescriptionNode, advancedSettingsPanel.firstChild);
                }
            }
            populateAdvancedGroups();
            bindAdvancedEvents();
            renderAdvancedControls(currentAdvancedGroup);
        }

        function populateAdvancedGroups() {
            const entries = Object.keys(advancedGroupConfig);
            advancedGroupSelect.innerHTML = '';
            entries.forEach((key) => {
                const groupInfo = advancedGroupConfig[key];
                const option = document.createElement('option');
                option.value = key;
                option.textContent = groupInfo.label;
                advancedGroupSelect.appendChild(option);
            });
            if (entries.indexOf(currentAdvancedGroup) === -1) {
                currentAdvancedGroup = entries[0];
            }
            advancedGroupSelect.value = currentAdvancedGroup;
        }

        function bindAdvancedEvents() {
            advancedGroupSelect.addEventListener('change', () => {
                const nextGroup = advancedGroupSelect.value;
                renderAdvancedControls(nextGroup);
            });
            if (advancedModeToggle) {
                advancedModeToggle.addEventListener('change', () => {
                    const enabled = advancedModeToggle.checked;
                    window.setAdvancedGroupEnabled(currentAdvancedGroup, enabled);
                    setAdvancedControlsDisabled(!enabled);
                });
            }
            if (advancedApplyButton) {
                advancedApplyButton.addEventListener('click', () => {
                    window.applyAdvancedGroup(currentAdvancedGroup, { source: 'manual' });
                });
            }
            if (advancedResetButton) {
                advancedResetButton.addEventListener('click', () => {
                    window.resetAdvancedGroup(currentAdvancedGroup);
                    renderAdvancedControls(currentAdvancedGroup);
                });
            }
            if (presetSaveButton) {
                presetSaveButton.addEventListener('click', () => {
                    const rawName = presetNameInput ? presetNameInput.value.trim() : '';
                    window.saveAdvancedPreset(currentAdvancedGroup, rawName || undefined);
                    if (presetNameInput) {
                        presetNameInput.value = '';
                    }
                    refreshPresetList(currentAdvancedGroup);
                });
            }
            if (presetDownloadButton) {
                presetDownloadButton.addEventListener('click', () => {
                    const state = window.getAdvancedSettings(currentAdvancedGroup);
                    if (!state || !state.settings) {
                        return;
                    }
                    const payload = {
                        version: 1,
                        group: currentAdvancedGroup,
                        name: `${advancedGroupConfig[currentAdvancedGroup].label} preset`,
                        settings: state.settings
                    };
                    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const downloader = document.createElement('a');
                    downloader.href = url;
                    downloader.download = `${currentAdvancedGroup}-settings.json`;
                    document.body.appendChild(downloader);
                    downloader.click();
                    document.body.removeChild(downloader);
                    URL.revokeObjectURL(url);
                });
            }
            if (presetUploadInput) {
                presetUploadInput.addEventListener('change', (event) => {
                    const file = event.target.files && event.target.files[0];
                    if (!file) {
                        return;
                    }
                    const reader = new FileReader();
                    reader.onload = () => {
                        try {
                            const parsed = JSON.parse(reader.result || '{}');
                            window.importAdvancedPreset(currentAdvancedGroup, parsed);
                            refreshPresetList(currentAdvancedGroup);
                            renderAdvancedControls(currentAdvancedGroup);
                        } catch (err) {
                            console.error('Failed to import preset', err);
                        }
                    };
                    reader.readAsText(file);
                    presetUploadInput.value = '';
                });
            }
        }

        function renderAdvancedControls(group) {
            const config = advancedGroupConfig[group];
            if (!config || !advancedContainer) {
                return;
            }
            currentAdvancedGroup = group;
            advancedGroupSelect.value = currentAdvancedGroup;
            const state = window.getAdvancedSettings(group) || { settings: {}, defaults: {}, enabled: false };
            const defaults = state.defaults || {};
            advancedValueDisplays = {};
            advancedContainer.innerHTML = '';
            if (advancedDescriptionNode) {
                advancedDescriptionNode.textContent = config.description || '';
                advancedDescriptionNode.classList.toggle('hidden', !config.description);
            }
            config.fields.forEach((field) => {
                const initial = state.settings && Object.prototype.hasOwnProperty.call(state.settings, field.key)
                    ? state.settings[field.key]
                    : defaults[field.key];
                const value = typeof initial === 'number' ? initial : defaults[field.key];
                const row = buildAdvancedControlRow(field, value);
                advancedContainer.appendChild(row);
            });
            const enabled = !!state.enabled;
            if (advancedModeToggle) {
                advancedModeToggle.checked = enabled;
            }
            setAdvancedControlsDisabled(!enabled);
            syncAdvancedConstraints(group);
            refreshPresetList(group);
        }

        function buildAdvancedControlRow(field, value) {
            const wrapper = document.createElement('div');
            wrapper.className = 'advanced-control-row';
            const label = document.createElement('label');
            label.className = 'advanced-control-label';
            label.htmlFor = `advanced-${field.key}`;
            label.textContent = field.label;

            const valueDisplay = document.createElement('span');
            valueDisplay.className = 'advanced-value-display';
            valueDisplay.textContent = formatAdvancedValue(value, field);
            label.appendChild(valueDisplay);

            const input = document.createElement('input');
            input.type = field.type === 'number' ? 'number' : 'range';
            input.id = `advanced-${field.key}`;
            input.dataset.key = field.key;
            input.min = field.min;
            input.max = field.max;
            if (field.step !== undefined) {
                input.step = field.step;
            }
            input.value = value;
            input.addEventListener('input', () => {
                const numeric = parseFloat(input.value);
                valueDisplay.textContent = formatAdvancedValue(numeric, field);
                window.updateAdvancedGroupSetting(currentAdvancedGroup, field.key, numeric);
                advancedValueDisplays[field.key] = { element: valueDisplay, field };
                syncAdvancedConstraints(currentAdvancedGroup);
            });
            advancedValueDisplays[field.key] = { element: valueDisplay, field };

            wrapper.appendChild(label);
            wrapper.appendChild(input);
            if (field.description) {
                const hint = document.createElement('small');
                hint.className = 'advanced-hint';
                hint.textContent = field.description;
                wrapper.appendChild(hint);
            }
            return wrapper;
        }

        function formatAdvancedValue(value, field) {
            if (typeof field.format === 'function') {
                return field.format(value);
            }
            if (typeof value === 'number' && value % 1 !== 0) {
                return value.toFixed(2);
            }
            return `${value}`;
        }

        function setAdvancedControlsDisabled(disabled) {
            const disabledFlag = !!disabled;
            if (advancedContainer) {
                advancedContainer.querySelectorAll('input').forEach((node) => {
                    node.disabled = disabledFlag;
                });
            }
            if (advancedApplyButton) {
                advancedApplyButton.disabled = disabledFlag;
            }
            if (advancedResetButton) {
                advancedResetButton.disabled = disabledFlag;
            }
            if (presetSaveButton) {
                presetSaveButton.disabled = disabledFlag;
            }
            if (presetDownloadButton) {
                presetDownloadButton.disabled = disabledFlag;
            }
            if (presetUploadInput) {
                presetUploadInput.disabled = disabledFlag;
            }
        }

        function updateAdvancedValueDisplay(key, value) {
            const record = advancedValueDisplays[key];
            if (!record || !record.element) {
                return;
            }
            record.element.textContent = formatAdvancedValue(value, record.field);
        }

        function syncAdvancedConstraints(group) {
            if (!advancedContainer) {
                return;
            }
            if (group === 'canonOverlay' || group === 'eternalOverlay') {
                const minInput = advancedContainer.querySelector('input[data-key="minOffsetBeats"]');
                const maxInput = advancedContainer.querySelector('input[data-key="maxOffsetBeats"]');
                if (minInput && maxInput) {
                    const minValue = parseInt(minInput.value, 10) || 1;
                    const minForMax = Math.max(minValue + 1, parseInt(maxInput.min, 10) || minValue + 1);
                    maxInput.min = minForMax;
                    let maxValue = parseInt(maxInput.value, 10) || minForMax;
                    if (maxValue <= minValue) {
                        maxValue = minForMax;
                        maxInput.value = String(maxValue);
                        window.updateAdvancedGroupSetting(group, 'maxOffsetBeats', maxValue);
                        updateAdvancedValueDisplay('maxOffsetBeats', maxValue);
                    }
                }
            } else if (group === 'jukeboxLoop' || group === 'eternalLoop') {
                const minLoopInput = advancedContainer.querySelector('input[data-key="minLoopBeats"]');
                const maxSeqInput = advancedContainer.querySelector('input[data-key="maxSequentialBeats"]');
                if (minLoopInput && maxSeqInput) {
                    const minLoop = parseInt(minLoopInput.value, 10) || 4;
                    const minSeq = Math.max(minLoop + 2, parseInt(maxSeqInput.min, 10) || (minLoop + 2));
                    maxSeqInput.min = minSeq;
                    let maxSeq = parseInt(maxSeqInput.value, 10) || minSeq;
                    if (maxSeq <= minLoop) {
                        maxSeq = minSeq;
                        maxSeqInput.value = String(maxSeq);
                        window.updateAdvancedGroupSetting(group, 'maxSequentialBeats', maxSeq);
                        updateAdvancedValueDisplay('maxSequentialBeats', maxSeq);
                    }
                }
            }
        }

        function refreshPresetList(group) {
            if (!presetList) {
                return;
            }
            presetList.innerHTML = '';
            const presets = typeof window.getAdvancedPresets === 'function' ? window.getAdvancedPresets(group) : [];
            if (!presets || !presets.length) {
                const empty = document.createElement('div');
                empty.className = 'preset-empty-state';
                empty.textContent = 'No presets saved yet.';
                presetList.appendChild(empty);
                return;
            }
            presets.forEach((preset) => {
                const row = document.createElement('div');
                row.className = 'preset-item-row';
                const name = document.createElement('span');
                name.className = 'preset-item-name';
                name.textContent = preset.name;
                const actions = document.createElement('div');
                actions.className = 'preset-item-actions';
                const applyBtn = document.createElement('button');
                applyBtn.type = 'button';
                applyBtn.className = 'viz-button ghost';
                applyBtn.textContent = 'Apply';
                applyBtn.addEventListener('click', () => {
                    window.loadAdvancedPreset(group, preset.id);
                    renderAdvancedControls(group);
                });
                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'viz-button ghost';
                deleteBtn.textContent = 'Delete';
                deleteBtn.addEventListener('click', () => {
                    window.deleteAdvancedPreset(group, preset.id);
                    refreshPresetList(group);
                });
                actions.appendChild(applyBtn);
                actions.appendChild(deleteBtn);
                row.appendChild(name);
                row.appendChild(actions);
                presetList.appendChild(row);
            });
        }

        // helper to clear params when browser back/forward is used
        window.addEventListener('popstate', () => {
            const params = new URLSearchParams(window.location.search);
            if (!params.has('trid')) {
                setState('state-home');
                if (driver && typeof driver.stop === "function") {
                    driver.stop();
                }
            }
        });
    })();
    </script>
</body>
</html>

